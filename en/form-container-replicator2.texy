Form container replicator `$form->addDynamic()`
*********************************************************

.[perex]
Simple form container, which allows work with dynamic number of elements

|* Download | https://github.com/Kdyby/Framework/blob/master/libs/Kdyby/Forms/Containers/Replicator.php
|* Sandbox | https://github.com/hosiplan/nette-adddynamic
|* Autor | Filip Procházka


Instalation
=========

Copy the file to the folder, where RobotLoader can find it. And copy this code

/---code php
Kdyby\Forms\Containers\Replicator::register();
\---

 to `app/boostrap.php`, or `BasePresenter::startup()`.


Attach to Form
======================

It can be used for simple things, like a list of dates.

/---code php
use Nette\Forms\Container;

$form->addDynamic('dates', function (Container $container) {
        $container->addDate('date');
});
\---

Or it can be used for advanced combinations too. For example, users and theirs addresses.

/---code php
$form->addDynamic('users', function (Container $user) {
        $user->addText('name', 'Jméno');
        $user->addText('surname', 'Příjmení');
        $user->addDynamic('addresses', function (Container $address) {
                $address->addText('street', 'Ulice');
                $address->addText('city', 'Město');
                $address->addText('zip', 'PSČ');
                // ...
        }, 1);
        // ...
}, 2);
\---


Container handling
==========

Handling is trivial, just iterate over the values.

/---code php
use Nette\Application\UI\Form;

public function FormSubmitted(Form $form)
{
	foreach ($form['users']->values as $user) { // values of form element
		dump($user['name'] . ' ' . $user['surname']);

		foreach ($user['addresses'] as $address) { // work with array of values
			dump($address['city']);
		}
	}
}
\---


Editing records
===============

It is suitable to use the keys of nested containers as identifiers. It is even possible to write this


/---code php
public function actionEditUsers()
{
	$form = $this['myForm'];
	if (!$form->isSubmitted()) { # if form was not sent
		# assumes instance of model in presenter's property $model
		$users = $this->model->findAll();
		foreach ($users as $user) {
			$form['users'][$user->id]->setValues($user);
			# container with defaults
		}
	}
}
\---

And edit handling

/---code php
public function FormSubmitted(Form $form)
{
	foreach ($form['users']->values as $userId => $user) {
	# now both the user ID and the form values are accessible
	// ...
\---


Adding and removing containers
================================

In the sandbox there is an example where in one line with container, there is a remove button and below all containers there is an adding button

/---code php
protected function createComponentMyForm()
{
	$form = new Nette\Application\UI\Form;

	// name, factory, default number
	$removeEvent = callback($this, 'MyFormRemoveElementClicked');
	$users = $form->addDynamic('users', function (Container $user) use ($removeEvent) {
		// ...
		$user->addSubmit('remove', 'Delete')
			->setValidationScope(FALSE) # disable validation
			->onClick[] = $removeEvent;
	}, 1);

	$users->addSubmit('add', 'Add next person')
		->setValidationScope(FALSE)
		->onClick[] = callback($this, 'MyFormAddElementClicked');

	// ...
\---

Adding of anotherbutton is easy.

/---code php
use use Nette\Forms\Controls\SubmitButton;

public function MyFormAddElementClicked(SubmitButton $button)
{
	$button->parent->createOne();
}
\---

If you want to allow to always add just one empty input then you can check if the current ones are fill and use a condition for adding.

/---code php
public function MyFormAddElementClicked(SubmitButton $button)
{
	$users = $button->parent;

	// count, if inputs were filled
	// ignore value of button
	if ($users->countFilledWithout(array('add')) == count($users->containers)) {
		// add one line to the container
		$button->parent->createOne();
	}
}
\---

Replicator's method `countFilledWithout` checks if form's elements has some values. Argument says which will be ignored. In this example the element "add" won't be validated because it is a button.

If user clicks on Delete, action `MyFormRemoveElementClicked` will be called

/---code php
public function MyFormRemoveElementClicked(SubmitButton $button)
{
	// first parent is container
	// second parent is his replicator
	$users = $button->parent->parent;
	$users->remove($button->parent, TRUE);
}
\---

If we want to delete the user from the database and we have element's keys as identificators we get the value like this

/---code php
public function MyFormRemoveElementClicked(SubmitButton $button)
{
	$id = $button->parent->name;
\---



Todo
====

- add automatic ignore of submit buttons in counting filled elements

{{author: newPOPE|2127}}
