Ormion
######

ORM pro Nette a dibi. .[perex]

| github | http://github.com/janmarek/Ormion
| Autor | Jan Marek
| Licence | MIT

Ormion vyžaduje PHP 5.3. .[caution]

Instalace
*********

Zkopírujte do adresáře `libs` složku `Ormion` a třídu `LazyArrayList`. Vytvořte "složku `%appDir%/models/config`"((složku lze změnit pomocí Environment proměnné ormionConfigDir)), do které se budou ukládat konfigurační soubory. Před jejich prvním vygenerováním v této složce musí být povolen zápis.

Připojení k databázi
********************

/--code php
Ormion::connect(Environment::getConfig("database"));
\--

Funkce `Ormion::connect` pouze zavolá funkci `dibi::connect`. Jen nastavuje výchozí jméno připojení na `ormion`. Jméno lze ovlivnit volitelným druhým parametrem.

Vytvoření modelu
****************

Pro základní funkčnost modelu je potřeba jen nastavit jméno tabulky.

/--code php
class Article extends OrmionRecord {

	protected static $table = "articles";

}
\--

Model bude načítat "údaje o databázi"((typy sloupců, jména klíčů apod.)) z konfiguračního souboru, který vytvoří v umístění `%appDir%/models/config/tableName.ini` v momentě, kdy jej bude poprvé potřebovat. Například při vkládání nebo čtení dat.

**Ukázka konfiguračního souboru**

/--code
; generated by Nette

[column]
id.type = "i"
name.type = "s"
url.type = "s"
description.type = "s"
description.nullable = true
keywords.type = "s"
keywords.nullable = true
text.type = "s"
created.type = "t"
updated.type = "t"
allowed.type = "b"

[key]
id.primary = true
id.autoIncrement = true
\--

Z databáze není možné detekovat typ boolean, proto je vhodné toto v configu upravit.

.[tip]
Ve výchozím nastavení se do configů zapisují i data pro případné generování formuláře. Toto chování lze vypnout přes nastavení `OrmionConfig::$generateForms = false;`.

Práce se záznamem
*****************

Vytvoření záznamu:

/--code php
$article = new Article;

$article = Article::create();

// s přednastavenými daty
$article = Article::create(array(
	"id" => 4,
	"name" => "Nový článek",
	"text" => "Text článku",
	// ...
));

// s přednastaveným primárním klíčem
$article = Article::create(4);
\--

Nastavování a čtení dat záznamu:
/--code php
// nastavení hodnoty name
$article->name = "Název";

// lze použít ArrayAccess
$article["name"] = "Název";

// čtení
echo $article->name;

// hodnoty jsou automaticky přetypovány
$article->id = "4";
is_int($article->id); // true

// je hodnota nastavena?
isset($article->name);

// je hodnota nastavena nebo je alespoň null?
$article->hasValue("name");

// Čtení nenastavené hodnoty vyvolá výjimku.

// zrušení hodnoty
unset($article->name);

// Hromadný getter a setter lze najít pod metodami getValues, setValues.
\--

Uložení záznamu - jestli je záznam vkládán nebo upravován ovlivňuje stav nastavitelný pomocí metody `setState`, případně přítomnost či nepřítomnost primárního klíče. V případě úpravy záznamu jsou ukládány jen změněné hodnoty.
/--code php
$article->save();
\--

Smazání záznamu z databáze:
/--code php
$article->delete();
\--

.[tip]
Hodnoty záznamu lze procházet pomocí cyklu, takže je možné nastavit záznam jako výchozí hodnoty formuláře. `$form->setDefaults($article);`

Výběr dat
*********

Výběr jednoho záznamu:

/--code php
// vyhledání pomocí primárního klíče
$article = Article::find(123);

// vyhledání podle jiných hodnot
$article = Article::find(array(
	"author" => 4,
	"allowed" => true,
));

// nebo alternativně
$article = Article::findByAuthorAndAllowed(4, true);

// také lze využít lazy loadingu, kdy nenačtené hodnoty jsou v případě potřeby doplněny z databáze
$article = Article::create($id);
echo $article->name;
\--

Výběr kolekce záznamů:
/--code php
// získání všech záznamů
$articles = Article::findAll();

// vyhledání záznamů podle určitých hodnot
$articles = Article::findAll(array(
	"author" => 4,
	"allowed" => true,
));

// nebo alternativně
$articles = Article::findAllByAuthorAndAllowed(4, true);
\--

Vyhledání více záznamů vrací objekt třídy OrmionCollection. Ten zatím nemá data načtená (načte je až budou potřeba), protože umožňuje s kolekcí dále pracovat podobně jako lze upravovat třídu `DibiFluent`.

/--code php
$articles = Article::findAll()->where("[author] = %i", 4)->orderBy("[date] DESC")->limit("0, 10");
\--

Získání počtu záznamů:
/--code php
$count = count($articles);
\--

Pokud záznamy již nejsou načteny, zavolá se dotaz typu `select count(*) from ...`.

Počítání počtu záznamů nefunguje v aktuální stable verzi dibi, je nutné použít vývojovou verzi. .[caution]


Přizpůsobení OrmionRecordu
**************************

Přepsáním metody init lze upravit chování OrmionRecordu.

/--code php
class Article extends OrmionRecord {

	protected static $table = "articles";

	protected function init() {
		// nastavení výchozích dat
		$this->setDefaultValue("text", "Lorem Ipsum, Dorot Sir Ahmed");
		// (lze nastavit pouze v této metodě,
		// na pozdější nastavování nebude brán zřetel :)


		// nastavení aliasů sloupců
		$this->setAlias("content", "text");


		// nastavení filtrů (callbacky, které berou vstup, upraví ho a vrátí)
		$this->addOutputFilter("name", "String::lower");
		// jméno bude při čtení převedeno na malá písmenka

		// $this->addInputFilter("name", "String::lower");


		// nastavení komplexních callbacků
		$this->registerGetter("url", array($this, "getUrl"));
		// $this->registerSetter(..., ...);
		// i pro tyto callbacky jsou zohledněny filtry a konvertování hodnot na správný typ


		// nastavení událostí
		$this->onBeforeDelete[] = array($this, "deleteComments");
		// Existují ještě onAfterDelete, onBeforeInsert, onAfterInsert, onBeforeUpdate, onAfterUpdate
	}

	public function getUrl() {
		return $this->id . "-" . String::webalize($this->name);
	}

	public function deleteComments() {
		foreach (Comments::findAllByParent($this->id) as $comment) {
			$comment->delete();
		}
	}

}
\--

Generování formulářů
********************


Behaviors
*********
Podrobné nastavování modelu lze vyčlenit do třídy implementující "rozhranní `IBehavior`"((jediná metoda setUp(IRecord $record) )) a poté používat opakovaně.

V distribuci již některé příklady jsou:

`TimestampableBehavior` při vytvoření nastaví aktuální čas na sloupci (např.) created, při úpravě aktualizuje čas na sloupci (např.) updated.

/--code php
class Article extends OrmionRecord {

	protected static $table = "articles";

	protected function init() {
		$this->addBehavior(new TimestampableBehavior("created", "updated"));
	}

}
\--

`SortableBehavior` udržuje sloupec (např.) order seřazený hezky lineárně 1, 2, 3, 4, ... i při mazání, změně pořadí, vkládání nových záznamů a podobně. Lze rozkategorizovat podle další hodnoty (např. parent).

/--code php
class Article extends OrmionRecord {

	protected static $table = "articles";

	protected function init() {
		$this->addBehavior(new SortableBehavior("order", "parent"));
	}

}

$article1 = Article::create()->save();
$article2 = Article::create()->save();
$article3 = Article::create()->save();
$article4 = Article::create()->save();

echo $article1->order . " " $article2->order . " " . $article3->order . " " . $article4->order;
// vypíše 1 2 3 4

$article4->order = 2;
$article4->save();

echo $article1->order . " " $article2->order . " " . $article3->order . " " . $article4->order;
// vypíše 1 3 4 2
\--

`TexyBehavior` umožňuje získávat pod hodnotou (např.) `htmlText` cachovaný výstup hodnoty ze zdrojového sloupce (např.) `text`.

/--code php
class Article extends OrmionRecord {

	protected static $table = "articles";

	protected function init() {
		$this->addBehavior(new TexyBehavior("htmlText", "text", "MyTexyClass"));
	}

}
\--

`HashableBehavior` dokáže zahashovat při vkládání hodnoty a při změně hodnoty zvolený sloupec, např. `password`.

{{author: Honza Marek|516}}
