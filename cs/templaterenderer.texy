TemplateRenderer
****************

.[perex]
Je renderer, který umožňuje vlastní znovupoužitelné vykreslování formulářů, které se neplate v hlavní šabloně.

.[caution]
Následující kód je spíše naznačení směru, kterým se vydat, pokud člověk potřebuje vlastní vykreslování. V žádném případě se nejdená o finální kód! Návrhy na zlepšení piště na fórum

/---code php

/**
 * FormTemplateRenderer is render with you can
 * render **really** custom forms without creating component.
 *
 * Usage is really trivial:
 * $form = AppForm($this,"test");
 * $form->addSomething("test","test");
 * $form->setRenderer(
 *	new FormTemplateRenderer(APP_DIR."/templates/myFormTemplate.phtml")
 * );
 * $form->render();
 *
 *
 * In template shoud be something like this:
 * {? $render->renderBegin();}
 * {? $render->renderErrors();}
 * <table>
 *	<tr>
 *		<th>{!$form["test"]->label}</th>
 *		<td>{!$form["test"]->control}</td>
 *	</tr>
 * </table>
 * {? $render->renderEnd();}
 *
 */
class FormTemplateRenderer extends Object implements IFormRenderer {

	/**
	 * Template path
	 * @var string
	 */
	private $template;

	/**
	 * Form
	 * @var Form
	 */
	protected $form;

	/**
	 * Callback
	 * @var array
	 */
	public $onBeforeRender = array();

	/**
	 * @param string $template
	 */
	function  __construct($template) {
		$this->setTemplate($template);
	}

	/**
	 * Getts template path
	 * @return string
	 */
	function getTemplate() {
		if(!$this->template) {
			throw new InvalidStateException("Template is not set!");
		}
		return $this->template;
	}

	/**
	 * Setts template path
	 * @param string $template
	 * @return FormTemplateRenderer Provides fluent interface.
	 */
	function setTemplate($template) {
		if(!file_exists($template)) {
			throw new InvalidStateException("Template not found!");
		}
		$this->template = $template;
		return $this;
	}

	/**
	 * Renders the form
	 * @param Form $form
	 */
	function render(Form $form) {
		$this->form = $form;
		$this->onBeforeRender($this);

		// Creates template
		$template = $form->getParent()->createTemplate()->setFile($this->getTemplate());
		$template->form = $form;
		$template->render = $this;
		$template->render();
	}

	/**
	 * Creates template
	 * @return Template
	 */
	/*public function createTemplate($file = null){
		$template = new Template($file);
		$presenter = $this->form->getParent()->getPresenter(FALSE);
		$template->onPrepareFilters[] = array("FormTemplateRenderer", 'templatePrepareFilters');
		$template->presenter = $presenter;
		$template->baseUri = Environment::getVariable('baseUri');
		$template->basePath = rtrim($template->baseUri, '/');
		return $template;
	}*/

	/**
	 * Descendant can override this method to customize template compile-time filters.
	 * @param  Template
	 * @return void
	 */
	/*public static function templatePrepareFilters($template)
	{
		// default filters
		$template->registerFilter(new LatteFilter);
	}*/


	// Rendering helpers ->>


	/**
	 * @var ConventionalRenderer
	 */
	private $convenctionalRenderer;

	/**
	 * @return ConventionalRenderer
	 */
	private function getConventionalRenderer() {
		if(!$this->convenctionalRenderer)
			$this->convenctionalRenderer = new ConventionalRenderer();
		return $this->convenctionalRenderer;
	}

	function renderBegin() {
		echo $this->getConventionalRenderer()->render($this->form, "begin");
		return $this;
	}

	function renderErrors() {
		echo $this->getConventionalRenderer()->render($this->form, "errors");
		return $this;
	}

	function renderBody() {
		echo $this->getConventionalRenderer()->render($this->form, "body");
		return $this;
	}

	function renderEnd() {
		echo $this->getConventionalRenderer()->render($this->form, "end");
		return $this;
	}
}

\---

Tato třída vyžaduje přepsání metody creteTemplate na public, nebo si třídu musíte upravit tak, aby vytvářela šablonu jiným způsobem - naznačeno v komentáři zhruba uprostřed kódu.

Verze připravené k použití: Formulář na řádku
----------

Renderer:
/---code php

/**
 *
 * FormOnTwoRowsRenderer renders form on two rows
 *
 */
class FormOnOneRowRenderer extends FormTemplateRenderer {

	function  __construct() {
		$this->setTemplate(dirname(__FILE__)."/template.phtml");
	}

}

\---

template:
/---code html

{? $render->renderBegin();}
{? $render->renderErrors();}
<?php

$controls = $form->getComponents(TRUE, 'Nette\Forms\IFormControl');

?>

<table class="vertical-align-top">
	<tr style="text-align: left;">
		<th n:foreach="$controls AS $control">
			{!$control->label}
		</th>
	</tr>
	<tr>
		<td n:foreach="$controls AS $control">
			{!$control->control}
		</td>
	</tr>
</table>


{? $render->renderEnd();}

\---

Verze připravené k použití: Formulář na řádku a tlačtko na dalším
----------

renderer:
/---code php
/**
 *
 * FormOnTwoRowsRenderer renders form on two rows
 *
 */
class FormOnTwoRowsRenderer extends FormTemplateRenderer {

	function  __construct() {
		$this->setTemplate(dirname(__FILE__)."/template.phtml");
	}

}
\---

template:
/---code html
{? $render->renderBegin();}
{? $render->renderErrors();}
<?php

$controls = $form->getComponents(TRUE, 'Nette\Forms\IFormControl');
$fControls = array();
$fButtons = array();
foreach($controls AS $key => $fControl) {
	if($fControl instanceof Button)	{
		$fButtons[$key] = $fControl;
	} else {
		$fControls[$key] = $fControl;
	}
}
unset($controls);

?>

<table class="vertical-align-top">
	<tr style="text-align: left;">
		<th n:foreach="$fControls AS $fcontrol">
			{!$fcontrol->label}
		</th>
	</tr>
	<tr>
		<td n:foreach="$fControls AS $fcontrol">
			{!$fcontrol->control}
		</td>
	</tr>
	<tr>
		<td colspan="{=count($fControls)}" style="text-align:right;" n:inner-foreach="$fButtons AS $button">
			{!$button->control}
		</td>
	</tr>
</table>


{? $render->renderEnd();}
\---

{{author: Honza Kuchař|1018}}
