DataGrid
********


.[perex]
Komponenta výrazně **zjednodušuje tvorbu** přehledových tabulek a **zajišťuje vizuální prezentaci** těchto dat uživateli. Umožňuje data rychle třídit, filtrovat a manipulovat s nimi uživatelsky definovanými rutinami. A to vše **s plnou AJAXovou podporou** pro maximální uživatelský požitek.


|Verze | beta
|Download | [nette-datagrid-beta.zip | http://nette-datagrid.googlecode.com/files/nette-datagrid-beta.zip] (861 kB)
|Demo | http://demo.datagrid.romansklenar.cz
|Autor | Roman Sklenář
|Licence | Nette license [cs | http://nette.org/cs/nette-licence], [en | http://nette.org/en/nette-license]
|Homepage | [http://nette-datagrid.googlecode.com | http://code.google.com/p/nette-datagrid]


Ukázka
===============
[* datagrid.png *] *** Ukázka uživatelského rozhraní .<>


Použití
===============

DataGrid vytvoříme nejlépe továrničkou na komponenty.

Vytvoření komponenty
--------------------

/---php
protected function createComponent($name)
{
	switch ($name) {
	case 'dg':
		$grid = new DataGrid;
		$model = new Model;
		$grid->bindDataTable($model->getDataSource('customers'));
		$this->addComponent($grid, $name);
		return;
	}
}
\---

Tímto jsme si nadefinovali jednoduchý datagrid. Jediné, co nutně potřebuje, je zdroj dat, ze kterých má čerpat. Ten mu předáme metodou `bindDataTable()`, která přijme data ve formě [DibiDataSource | http://api.dibiphp.com/1.3/DibiDataSource.html]. Příklad výše předpokládá třídu `Model` s metodou `getDataSource($table)` vracející `DibiDataSource` tabulky ze zadané databáze. `DibiDataSource` může mít více podob, proto **je možné zobrazit data ze složených dotazů včetně spojování tabulek.** Konkrétní implementace modelů i podoby datasourců jsou tedy plně na vás.

V presenteru si jej pouze zavoláme a předáme šabloně.

/---php
// presenter
public function renderDefault()
{
	$this->template->grid = $this->getComponent('dg');
}
\--

Šablona si datagrid vykreslí zavoláním metody render. AJAXovou funkčnost získáte klasickým aplikováním zavináče před volání této funkce.

/---code html
{* vykreslení v šabloně *}
@{? $grid->render()}

{* alternativně *}
@{!$grid}
\---

Tento datagrid automaticky vykreslí všechny sloupce z předaného datasourcu, podle kterých umožní vícenásobné řazení a zobrazí 15 položek (řádků) na stránku.

Chceme-li řadit pouze podle jednoho sloupce a zobrazit na stránku například pouze 10 položek, upravíme si definici datagridu v továrničce.

/---php
$grid->itemsPerPage = 10; // zobraz pouze 10 řádků na stránku
$grid->multiOrder = FALSE; // pro řazení použij vždy jen jeden sloupec
\---

Nicméně jsme stále na začátku. Takovýto datagrid bude jistě obsahovat sloupce, které nechceme uživateli zobrazit, například primární a cizí klíče. To se dá lehce změnit.

Sloupce
-------
Třída `DataGrid` obsahuje sadu továrniček, které vytvoří instance tříd reprezentující sloupce, se kterými datagrid vnitřně pracuje.

Lze takto například přidávat sloupce pro zobrazení atributů textového charakteru či reprezentující čísla, logické hodnoty nebo data.

/---php
// sloupce pro textové atributy
$grid->addColumn('customerName', 'Zákazník');
$grid->addColumn('contactLastName', 'Kontaktní osoba');
$grid->addColumn('city', 'Město');

// reprezentace logických hodnot je realizována checkboxy
// číslo větší než 1 je považováno za pravdivou logickou hodnotu
$grid->addCheckboxColumn('orders', 'Má objednávky?');

// sloupec pro zobrazení datumu či času
$grid->addDateColumn('orderDate', 'Datum poslední objednávky');

// sloupec pro číselné atributy
$grid->addNumericColumn('creditLimit', 'Limit kreditu');

\--

Všechny mají společnou syntax prvních dvou parametrů: název atributu z datasource a textový popis. Další parametry jsou volitelné ale stojí také za zmínku. Přepíšeme s nimi tedy úvodní definici.

/---php
$grid->addColumn('customerName', 'Zákazník');
$grid->addColumn('contactLastName', 'Kontaktní osoba', 30); // ořež text delší než 30 znaků
$grid->addColumn('city', 'Město');
$grid->addCheckboxColumn('orders', 'Má objednávky?');
$grid->addDateColumn('orderDate', 'Datum poslední objednávky', '%m/%d/%Y'); // český formát: '%d.%m.%Y'
$grid->addNumericColumn('creditLimit', 'Limit kreditu', 0); // počet desetinných míst
\--

Popisky přijímají i objekty [Nette\Web\Html], takže můžeme si dovolit i definice, například pro zkrácení názvu u sloupců reprezentující logické hodnoty zobrazující jen checkboxy, u kterých by se zbytečně plýtvalo místem.

/---php
$caption = Html::el('span')->setText('O')->title('Má objednávky?')->class('link');
$grid->addCheckboxColumn('orders', $caption)
\---

Filtry
------
Abychom mohli data dohledávat lépe než se k nim proklikávat na určitou stránku, můžeme přidat filtrační pole, které slouží uživateli jako vstupy. Filtry vytváříme na konkrétním sloupci opět továrničkou (tentokrát už továrničku zaštiťuje samotný sloupec, na datagrid) a opět jich máme ve výchozím stavu povícero druhů.


/---php
// přidání filtru při definici sloupce (Fluent rozhraní)
$grid->addColumn('customerName', 'Zákazník')->addFilter();

// alternativně při již definovaném sloupci (přes ArrayAccess)
$grid['customerName']->addFilter();

// tam kde to má smysl, můžeme filtrovat pomocí selectboxu nebo checkboxu
$grid['city']->addSelectboxFilter();
$grid['orders']->addCheckboxFilter();
\---

Občas ale není filtrování pomocí checkboxu vhodné, má totiž jen 2 stavy (odškrtnuto/zaškrtnuto), a je lepší použít selectbox a předat mu parametrem asociativní pole hodnot, kterých filtr může nabývat.

/---php
// druhý parametr je jen zkratka pro známé skipFirst() z Nette\Forms\SelectBox
$grid['orders']->addSelectboxFilter(array('?' => '?', '0' => "Nemá objednávky", '1' => "Má objednávky"), TRUE);
\---

Položky selectboxů jsou automaticky překládány translátorem pokud je definován (o tom níže), takže pokud je filtr selectboxu číselník jako sloupec `city` (narozdíl od sloupce `orders`, který obsahuje námi definované hodnoty), tak se nám nevyplatí jej překládat a může to být v jistých případech brzda aplikace. Proto můžeme volitelně automatické překládání vypnout.

/---php
$grid['city']->addSelectboxFilter()->translateItems(FALSE);
\---

Použitý sloupec definuje i jakým způsobem lze data filtrovat.
- pro číselné datové typy umožňuje `NumericColumn` filtrovat data pomocí operátorů `>, >=, <, <=, =, <>`
- pro textové datové typy umožňuje `TextColumn` filtrovat za použití syntaxe jednoduchých regulárních výrazů s podporou automatického přepisu hvězdiček (`auto*` -> `^auto.*`, `*mobil` -> `.*mobil$`) pro netechnicky založené uživatele, kteří znají použití hvězdičky jako zástupný znak pro *cokoliv* například z Windows či Wordu

.[note]
Databáze SQLite2 nepodporuje klíčové slovo `REGEXP`, proto je pro podporu této funkčnosti nutné [zaregistrovat vlastní funkci | http://api.dibiphp.com/1.3/DibiSqliteDriver.html#_registerFunction]. Konkrétní ukázku je možné nalézt [v modelu | http://code.google.com/p/nette-datagrid/source/browse/trunk/app/models/BaseModel.php] demo aplikace.

Pokud vám chování nějakého filtru nevyhovuje, můžete jej podědit či rovnou vytvořit nový, aniž byste přišli o luxus továrničky tím, že pomocí [extension metody | http://nette.org/cs/nette-object#toc-extension-method] tuto továrničku ke třídě `DataGridColumn` připojíte.


Formátování obsahu
------------------

Jsou případy, kdy potřebujeme nějakým způsobem upravit hodnoty, které sloupec vypisuje. Je více způsobů jak toho docílit, napřiklad nastavením sloupci nějakou CSS vlastnost (zarovnání, šířka, ...) nebo můžeme hodnoty sloupce před vypsáním prohnat přes nadefinované funkce či případně nastavit výrazy, které se mají nahrazovat určitým řetězcem.

Ovlivnění obsahu přes CSS funguje na stejném principu jako ve formulářích.

/---php
// ovlivnění formátování obsahu při definici sloupce (Fluent rozhraní)
$grid->addColumn('customerName', 'Zákazník')->getHeaderPrototype()->style('width: 180px');
$grid->addNumericColumn('creditLimit', 'Limit kreditu', 0)->getCellPrototype()->style('text-align: center');

// alternativně při již definovaném sloupci (přes ArrayAccess)
$grid['customerName']->getHeaderPrototype()->style('width: 180px');
$grid['creditLimit']->getCellPrototype()->style('text-align: center');
$grid['actions']->getHeaderPrototype()->style('width: 100px'); // pro sloupec akcí (viz. níže)
\---

Uživatelské funkce (callbacky) ke sloupci můžeme přiřadit následujícím způsobem.
/---code php
// předpokládejme sloupec, jehož obsahem je například velikost souboru
$grid['size']->formatCallback[] = 'TemplateHelpers::bytes';
\---

A nakonec nahrazování určitých výrazů je realizováno asociativním polem, který pojme i objekty `Html`.

/---php
// předpokládejme sloupec se statusem objednávky
$el = Html::el('span')->style('margin: 0 auto');
$grid['status']->replacement['Shipped'] = clone $el->class("icon icon-shipped")->title("Doručeno");
$grid['status']->replacement['Resolved'] = clone $el->class("icon icon-resolved")->title("Vyřešeno");
$grid['status']->replacement['Cancelled'] = clone $el->class("icon icon-cancelled")->title("Zrušeno");
\--

Vše je prováděno přesně v tomto pořadí.

To bylo ke sloupcům, ale jiná je situace, potřebujeme-li změnit způsob vykreslování samotného datagridu. Jelikož `DataGrid` patří mezi vykreslitelné komponenty tak není třeba se zatěžovat jeho vykreslováním, což ale pro někoho nemusí být ideální. Vykreslení je realizováno  podobně jako u [Nette\Forms] vlastní třídou `DataGridRenderer` obsahující taktéž pole wrapperů pro základní úpravy obsahu bez nutnosti dědit a psát vlastní vykreslovač. Pro jednoduché úpravy tedy dokáže dobře posloužit.

/---code php
$renderer = $grid->getRenderer();
$renderer->paginatorFormat = '%input%'; // upravíme formát výpisu footeru datagridu
$renderer->wrappers['error']['container'] = 'div class=error';
$renderer->wrappers['error']['item'] = 'span';
$grid->setRenderer($renderer);
\---

Pro další uživatelské úpravy je možné vykreslit datagrid i manuálně v šabloně.

/---code html
{? $grid->render('begin')}
{? $grid->render('errors')}
{? $grid->render('body')}
{? $grid->render('paginator')}
{? $grid->render('end')}
{? $grid->render('info')}
\---


Akce
----
Akce zajišťují manipulaci s datagridem na úrovni jednoho záznamu. Jako příklad uvedu vytvoření a smazání záznamu. Aby se se záznamy dalo manipulovat, musí být určen nějaký klíč (pro zjednodušení a v mnohých případech jím bude primární klíč), podle kterého se bude k záznamům přistupovat a který je i součástí datasourcu předaného datagridu.

/---php
// nastavíme klíč pro akce (a také i pro operace, o těch později)
$grid->keyName = 'customerNumber';

// přidáme sloupec pro akce
$grid->addActionColumn('Actions');

// a naplníme datagrid akcemi pomocí továrničky
$grid->addAction('Nový', 'Customer:new', Html::el('span')->class('icon icon-new'), $useAjax = FALSE, $type = DataGridAction::WITHOUT_KEY);
$grid->addAction('Smaž', 'customerDelete!', Html::el('span')->class('icon icon-del'), $useAjax = TRUE);
\---

Nyní si parametry továrničky trošku rozebereme:
 `addAction($title, $signal, $icon = NULL, $useAjax = FALSE, $type = DataGridAction::WITH_KEY)`
- textový popisek odkazu nebo-li html atribut `title`
- cíl odkazu zapsaný klasickým způsobem, jakým se v Nette tvoří odkazy
- obsah odkazu, nejčastěji `Html` objekt reprezentující nějakou ikonku akce, pokud není uveden je použit parametr `$title`
- pokud se má použít AJAX, přidá se do vygenerovaného odkazu atribut `class` s obsahem proměnné `DataGridAction::$ajaxClass`
- má-li být součástí vygenerovaného odkazu i klíč záznamu (logická hodnota nebo konstanta)

Mohli jste si všimnout, že akce vede buď na signál nebo třeba na úplně jiný presenter. V připadě signálu `customerDelete!` bude při zpracování volána metoda `handleCustomerDelete($id)`, kde obsah parametru `$id` bude právě klíč daného záznamu (nebo-li hodnota atributu `customerNumber` záznamu).


Operace
-------
Dostáváme se k případům, kdy potřebujeme manipulovat s daty datagridu na úrovni více záznamů (hromadné operace se záznamy) jako například mazání více záznamů. Záznamy, chcete-li řádky, si označíme přes checkboxy, vybereme operaci, která se bude provádět, odešleme a uživatelsky nadefinovaný handler tuto operaci zpracuje, pokud je vhodně napsán tak i AJAXově. Jak tedy na to?

/---php
// nadefinujeme si operace, tyto hodnoty je možno nechat překládat translatorem
$operations = array('delete' => 'smaž', 'deal' => 'vyřiď objednávky', 'print' => 'tiskni faktury');

// poté callback(y), které mají operaci zpracovat
$callback = array($this, 'gridOperationHandler'); // $this je presenter

// povolíme operace
$grid->allowOperations($operations, $callback, 'customerNumber');
// pozn: pokud je již uveden $grid->keyName není třeba poslední parametr udávat
\---

Zbývá zajistit zpracování handlerem `gridOperationHandler()`, jehož parametrem je tlačítko, kterým byla operace odeslána.

/---php
public function gridOperationHandler(SubmitButton $button)
{
	$form = $button->getParent();
	$grid = $this->getComponent('gf');
	$values = $form->getValues();

	// ... provedeme zpracování operace
	// název operace získáme z $values['operations']
	// a zda-li byl checkbox zaškrtnut zjistíme přes $values['checker'][123] => bool(TRUE)

	$grid->invalidateControl();
	if (!$this->presenter->isAjax()) $this->presenter->redirect('this');
}
\---

Při zaplém JavaScriptu v prohlížeči klienta, podporuje datagrid označení více položek pomocí kliknutí a podržení klávesy `SHIFT` nebo `CTRL`, konkrétně *kliknutí* -> `SHIFT` nebo `CTRL` + další *kliknutí* (`SHIFT` označuje v prohlížečích text, proto je možnost používat i `CTRL`, které je pro tyto případy vhodnější).


Lokalizace
---------
Samozřejmostí je i podpora lokalizace. Třída `DataGrid` disponuje potřebnými metodami, takže ho můžete bez obav použít i ve vícejazyčných systémech. Překládány jsou i titulky včetně `Html` objektů. V demo aplikaci je připravena ukázka konkrétní implementace překladače ([Translator | http://code.google.com/p/nette-datagrid/source/browse/trunk/app/components/Translator.php]) **podporující plurály i parametrizované překlady**, využívající GetTextových souborů, které binárně čte a parsuje, tudíž není nutné mít přítomný modul gettext v prostředí PHP a **odpadá nutnost při každé změně restartovat web server**, což se hodí především pro vývojová prostředí.

/---php
$translator = new Translator(Environment::expand('%templatesDir%/datagrid.cs.mo'));
$grid->setTranslator($translator);
\---

{{author: romansklenar|1728}}
