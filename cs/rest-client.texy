RestClient
***********

.[perex]
Jednoduchý HTTP a REST klient pro Nette inspirovaný implementací pro Ruby, podporující základní metody GET, POST, PUT a DELETE.

.[caution]
Tento dokument je prozatím draft, zdrojové kódy budou přiloženy nejpozději 9.3.2011

|* Forum thread | http://forum.nette.org/cs/6869-restclient-restful-klient-vyuzivajici-curl-umoznujici-i-multipart-pozadavky
|* Autor | Jakub Truneček
|* Autoři Ruby verze | Adam Wiggins, Blake Mizerany, Julien Kirch
|* Nette | 0.9+ PHP 5.3+

Instalace
=========

Rozšíření není potřeba nijak instalovat, stačí zdrojové soubory umístit například do složky `libs`, která je určena pro procházení RobotLoaderem.

.[caution]
Rozšíření počítá s autoloadingem dle "Best practice: načítání tříd a autloading":http://forum.nette.org/cs/650-best-practice-nacitani-trid-a-autoloading. Nejjistější je tedy mít cestu k rozšíření zahrnutou do adresářů, které prochází RobotLoader.


Příklady použití
================

Základní požadavky
------------------

Pro jednoduché dotazy je k dispozici "statická" třída `Thereto\RestClient\RestClient`, která poskytuje metody `get`, `post`, `put`, `head` a `options`. Její použití je následující

/--php
use \Thereto\RestClient\RestClient;

// Jednoduchý get
RestClient::get('http://example.com/resource');

// Get s parametry
RestClient::get('http://example.com/resource',
	array('params' => ('id' => 50, 'foo' => 'bar')));

// Get s přihlašovacími údaji a https společně s definicí vlastních hlaviček
RestClient::get('https://user:password@example.com/private/resource',
	array('accept' => 'application/json'));

// Typy obsahu lze napsat i krátce, automaticky se doplní
RestClient::get('https://user:password@example.com/private/resource',
	array('accept' => 'json'));

// Post s parametry
RestClient::post('http://example.com/resource',
	array('param1' => 'one', 'nested' => array('param2' => 'two')));

// Post json dat a definice hlaviček
RestClient::post("http://example.com/resource",
	json_encode(array('id' => 1)),
	array('content-type' => 'json', 'accept' => 'json'));

// Delete, jakmile chybí http[s] je automticky doplněno http
RestClient::delete('example.com/resource');
\--

Práce s odpovědí serveru
------------------------

Všechny požadavky vracejí odpověď jako instanci třídy `Thereto\RestClient\Response` a pracuje se s ní následovně:

/--php
use \Thereto\RestClient\RestClient;

$response = RestClient::get('http://example.com/resource');

// HTTP stavový kód
echo $response->code;
// 200

// Cookies zaslané serverem
echo print_r($response->cookies, true);
// array('foo' => 'bar', 'QUUX' => 'QUUUUX')

// Hlavičky odpovědi
echo print_r($response->headers, true);
// array(0 => 'HTTP/1.1 200 OK', 'contet-type' => 'text/html', 'cache-control' => 'private', ...)

// Jednotlivé hlavičky (Response implementuje ArrayAccess)
echo $response['content-type'];
// text/html

// Tělo odpovědi (implementace metody __toString())
echo $response;
// <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n   \"http://www.w3.org/TR/html4/strict.dtd\"> ...

\--

POST a data
-----------

Knihovna umí automaticky vybrat nejvhodnější formu odeslání dat na sever. Například při požadavku dle následujícího kódu:

/--php
use \Thereto\RestClient\RestClient;

RestClient::post($url, array(
	'name' => 'Jan',
	'surname' => 'Novák',
	'groups' => array(
		'group1', 'group2'
	)
));

\--

budou data odeslána jako content type `application/x-www-form-urlencoded`.

Multipart data
--------------

Součástí knihovny je i Multipart přenos dat na server, který se automaticky použije, pokud nahráváme soubor
/--php
use \Thereto\RestClient\RestClient;

RestClient::post($url, array(
	'name' => 'Jan',
	'surname' => 'Novák',
	'groups' => array(
		'group1', 'group2'
	),
	'photo' => new Thereto\IO\File('novak.jpg')
));

\--

lze si ho také vynutit nastavením klíče `multipart` na `true` v datovém poli, takto:

/--php
use \Thereto\RestClient\RestClient;

RestClient::post($url, array(
	'name' => 'Jan',
	'surname' => 'Novák',
	'groups' => array(
		'group1', 'group2'
	),
	'multipart' => true
));

\--

Při odesílání multipart dat obsahující soubory se automaticky určí MIME posílaného souboru a nastaví se tak v hlavičce pro každou položku (soubor).

.[note]
K určování MIME typů se používá knihovna Thereto\Mime

Třída Thereto\RestClient\Resource
---------------------------------

Pro možnost definování zdrojů je v knihovně implementována třída, která poskytuje elegantní řešení.

/--php
use \Thereto\RestClient\Resource;

$resource = new Resource('http://example.com');
// Základní get
$data = $resource->get();

// další noření
$image = $resource['image']->get(array('accept' => 'image/jpg'));
// požadavek bude odeslán na URL http://example.com/image s hlavičkou Accept: image/jpg

// odeslání dat
$res = $resource['posts']['id/1']['comments']->post('Nice post!', array('content-type' => 'txt'));
// požadavek bude odeslán na URL http://example.com/posts/id/1/comments
// s plain daty "Nice Post!"

\--

Výjimky
-------

- pro HTTP kód od 200 od 207 je vrácena instance třídy `Thereto\RestClient\Response`
- pro kódy 301, 302 nebo 307 se automaticky provede redirect, ale pouze v případě, že pokud požadavek byl GET nebo HEAD
- pro kód 303 se automatiky provede redirect a požadavek se převede na GET
- pro všechny ostatní kódy je vyhozena výjimka, která je potomkem od třídy `Thereto\RestClient\Exception` potažmo `Thereto\RestClient\ExceptionWithResponse`, která v sobě obsahuje `Thereto\Curl\Respons`. Třída výjimky je odvozena od známých HTTP stavových kódů a jejich názvů.

/--php
use \Thereto\RestClient\RestClient;

RestClient::get('http://google.com/404');
// Výjimka: Thereto\RestClient\ResourceNotFoundException #404 (404 Resource Not Found)

try {
    RestClient::get('http://google.com/404');
} catch (Thereto\RestClient\ExceptionWithResponse $ex) {
    echo $ex->getResponse();
}
// Výstup: HTTP/1.1 404 Not Found | text/html; charset=UTF-8 11778 bytes
\--

Výsledky a closures
-------------------

Do každého požadavku lze (volání metody třídy RestClient) lze vložit callback, který bude zavolán a předán
mu jako argument objekt třídy `Thereto\Curl\Respons`, pro aktivaci výchozího chování, lze na objekt zavolat metodu `rtrn`.

A block can be passed to the RestClient method, this block will then be called with the Response. Response.return! can be called to invoke the default response’s behavior.

/--php
use \Thereto\RestClient\RestClient;

RestClient::get('http://www.google.com/404', array(),
        function(\Thereto\RestClient\Response $response,
                 \Thereto\RestClient\Request $request,
                 \Thereto\RestClient\Curl\Response $result) {
            return $response;
        }
);
// Tento kód nevyvolá výjimku ResourceNotFoundException, pouze vrátí Response.


// Příklad užití (ošetření vlastního kódu)
RestClient::get('http://www.google.com/404', array(),
        function(\Thereto\RestClient\Response $response,
                 \Thereto\RestClient\Request $request,
                 \Thereto\RestClient\Curl\Response $result) {
            switch ($response->code) {
                case 200:
                    echo 'It worked!';
                    return $response;
                case 404:
                    throw new SomeCustomExceptionIfYouWant();
                default:
                    // Standardní chování
                    $response->rtrn($request, $result);
            }
        }
);



\--

Proxy
-----

Pro veškeré požadavky na server pomocí RestClient lze nastavit i proxy server, nastavení je následující:

/--php
use \Thereto\RestClient\RestClient;

// Globální nastavení proxy
RestClient::setProxy('login:password@123.123.123.123:5555');

// Každý požadavek nyní půjde přes proxy
RestClient::post('http://example.com',
	array('name' => 'Jan Novák',
	      'photo' => new Thereto\IO\File('novak.jpg')));

\--

Cookies
-------

RestClient umožňuje také práci s Cookies a to jak s odchozími tak příchozími:

/--php
use \Thereto\RestClient\RestClient;


$resp = RestClient::get('http://google.com');
// Tento požadavek bude automaticky 2x přesměrován
// Po prvé na http://www.google.com
// a po druhé na http://www.google.cz

echo print_r($resp->cookies, true);
// Cookies, které nám zaslal strýček Google
// výpíše něco jako: Array ( [NID] => 44=i46YmUpwICi8C3okWcQ_47KboMZ5KqZNI_TPngj_ ...

// Nyní posíláme cookies my
RestClient::get('http://google.com', array('cookies' => array('foo' => 'baz')));
// Odchozí hlavička bude vypadat asi takto
// > GET / HTTP/1.1
// User-Agent: RestClient 0.5
// Host: google.com
// Accept-Encoding: gzip, deflate
// Accept: */*; q=0.5, application/xml
// Cookie: foo=baz

\--

Hooky
-----

Statická metoda `RestClient::addBeforeExectutionProc(\Closure $proc)` umožňuje přidat funkci, která se bude
volat před každým requestem. To je užitečné, když potřebujete do-nastavit Curl, který je RestClientem zapouzdřen.

/--php

use \Thereto\RestClient\RestClient;

// aktivace "dubug" módu, kdy jsou odchozí hlavičky odeslány do prohlížeče
RestClient::addBeforeExecutionProc(function(Thereto\RestClient\Curl\Curl $curl) {
        $curl->verbose = true;
        $curl->stderr = fopen('php://output', 'w');
});

RestClient::get('http://www.google.cz');

// Výstup v prohlížeči
// * About to connect() to www.google.cz port 80 (#0)
// *   Trying 74.125.87.104... * connected
// * Connected to www.google.cz (74.125.87.104) port 80 (#0)
// > GET / HTTP/1.1
// User-Agent: RestClient 0.5
// Host: www.google.cz
// Accept-Encoding: gzip, deflate
// Accept: */*; q=0.5, application/xml
//
// < HTTP/1.1 200 OK
// < Date: Tue, 08 Mar 2011 11:17:21 GMT
// < Expires: -1
// < Cache-Control: private, max-age=0
// < Content-Type: text/html; charset=ISO-8859-2
// < Set-Cookie: PREF=ID=be0c7f4e66009915:FF=0:TM=1299583041:LM=1299583041:S=pgVfLLg0ZikV01h_; expires=Thu, // 07-Mar-2013 11:17:21 GMT; path=/; domain=.google.cz
// < Set-Cookie: NID=44=BlwW8Ln-xe3CH3TfazFBH1PlU5MXs_i_yovMPiYy4Od26JxkFSUXyIw9PYqwwSmoPI9dl1E2qHIcuERhALw4Cve89K6XxDoUtEqXa3PyEt7v0xMuoTHn// I_N93WMp89vT; expires=Wed, 07-Sep-2011 11:17:21 GMT; path=/; domain=.google.cz; HttpOnly
// < Server: gws
// < X-XSS-Protection: 1; mode=block
// < Transfer-Encoding: chunked
// <
// * Connection #0 to host www.google.cz left intact
// * Closing connection #0

\--

API nižší úrovně
================

Třídy `RestClient` a `Resource` poskytují, řekněme, API vyšší úrovně. Pokud požadujete práci na nižší úrovni, je možné využít třídu `Request`, která přímo zapouzdřuje práci s Curlem. Poskytuje následující API a nastavení:

/--php
class Request extends \Nette\Object
{
	//...
	public function __construct(array $args)
	{
		//...
	}

	public function exec(\Closure $block = null)
	{
		//...
	}

}
\--

Uvedeny jsou pouze důležité části, jmenovitě konstruktor a exekutivní metoda. Argumenty pro konstruktor
mohou být následující

- `method (*)` - metoda požadavku (GET, POST, PUT, DELETE, HEAD nebo OPTIONS)
- `headers` - hlavičky pro požadavek (očekáváno je pole, pokud toto pole obsahuje klíč `params` je převeden na QueryString a připojen k URL poždavku)
- `url (*)` - URL adresa požadavku (automaticky přidáváno http, pokud není definováno, je možné nastavit i uživ. jméno a heslo, které je později vyparsováno a předáno Curlu pomocí `setOpt`
- `cookies` - sušenky k odeslání
- `payload` - data (jsou akceptována pouze pro POST a PUT)
- `user` - uživatelské jméno
- `password` - heslo
- `timeout` - celkový timeout (pokud vyprší, je vyhozena výjimka)
- `openTimeout` - timeout pro navázání spojení (pokud vyprší, je vyhozena výjimka)
- `rawResponse`- pokud je nastaveno na true vrací nezpracovanou odpověď (`Thereto\RestClient\RawResponse`)
- `verifySsl` - kontrolovat SSL
- `sslClientCert` - certifikát
- `sslClientKey` - klíč k certifikátu
- `sslCaFile` - ca soubor

Argumenty se konstruktoru předávají formou asociativního pole, kde název klíče je název argumentu a hodnota je nastavovaná hodnota. Argumenty označené `(*)` jsou **mandatorní**, pokud nebudou nastaveny, bude vyhozena výjimka.

{{author: Trunda|3662}}
